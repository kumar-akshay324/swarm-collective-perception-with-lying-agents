# Use Shift + Click to select a robot
# When a robot is selected, its variables appear in this editor

# Use Ctrl + Click (Cmd + Click on Mac) to move a selected robot to a different location

# Global variables

OBSTACLE_COORDINATES = {}
WALL_DIAGONAL_COORDINATES = {.x1 = 4, .y1 = 4, .x2 = -4, .y2 = -4}

OBSTACLE_COUNT = 0
NUMBER_OF_SENSORS = 8

# ----- Helper Functions -----

# Function to compute the position from the distance and angle readings

function computePositionFromReadings(length, angle) {
   var local_position_vector 
   # var length = 4.14*(math.exp(-33.0*expressed_length))- 0.085
   # print ("(", "Length: ", length, ")")
   local_position_vector = { .x = length * math.cos(angle),.y = length * math.sin(angle) }
   return local_position_vector
}

# Function to compute the new position depending upon two coordinates

function computePosition(pos1, pos2) {
  var new_position_x = pos1.x + pos2.x
  var new_position_y = pos1.y + pos2.y
  pos1.x = new_position_x
  pos1.y = new_position_y 
  return pos1
}

# Function to compute the orientation in global FOR give the position (x, y) coordinates

function computeOrientation(pos) {
  var orientation = math.atan(pos.y, pos.x)
  return orientation
}

# ----- Function to Start the Buzz Script -----

function init() {
  log("Obstacle avoidance for Khepera IV using Buzz")
}

# ----- Function to run on each timestep -----

function step() {
  var i = 0
  var final_pos = {.x = 0 , .y = 0 }
  temp_pos = {}
  while (i < NUMBER_OF_SENSORS) 
  {

  distance = proximity[i].value             # Sensor reading
  orientation = proximity[i].angle          # Sensor reading

  # Position of the obstacle with respect to the robot

  temp_pos.i = computePositionFromReadings(distance, orientation)

  log("Iteration Number: ", i)

  final_pos = computePosition(temp_pos.i, final_pos)

  i = i+1
  log("Final Position = ", final_pos)
  }

  # Iteratively compute own position in space
  var robot_position = pose.position
  var robot_orient = pose.orientation


  # Iteratively updating the distance and orientation of the obstacle
  orient = computeOrientation(final_pos)

  dist = math.sqrt(final_pos.x*final_pos.x + final_pos.y*final_pos.y)
  dist_final = dist/3
  log("Orientation: ",orient)
  log("Distance: ", dist_final)

  # ---- Obstacle Avoidance Algorithm

  if (dist_final < 0.005){
   set_wheels(30.0,30.0)
  } 

  if ((orient == 0.0) and (dist_final > 0.005)){
   set_wheels(30.0, 0.0)
  }

  if ((orient < 1.57) and (orient > 0.0)){
   set_wheels(30.0,0.0)
  }

  if ((orient > -1.57) and (orient < 0.0)){
    set_wheels(0.0,30.0)
  }
}

# # Function to store positions of unique obstacles
# function StoreUniqueObstacles() {

#   return 5
  
# }

# Function to setup the robots to join a swarm
function SetupSwarm() {

  robot_swarm = swarm.create()
  var i = 0
  while (i < 10) {
    robot_swarm.select(i)
  }
  return robot_swarm                              # Returning a robot swarm of 15 robots
}


# # Function to setup the communication protocol for the robot

# function SetupSwarmCommunication() {

# }


# # Function to compute and save the locations of things that can NOT be an obstacle
# # Such things include the walls and the other robots that are detected.


function reset() {}

function destroy() {}