include "/usr/local/share/buzz/include/vec2.bzz"
include "/usr/local/share/buzz/include/string.bzz"

# Global variables
NUM_ROBOTS = 8
DISTANCE_THRESHOLD = 0.05
NUMBER_PROXIMITY_SENSORS = 8

PADDING = 0.5
WALL_DIAGONAL_COORDINATES = {.x1 = 4, .y1 = 4, .x2 = -4, .y2 = -4}
APPROX_OBS_DISTANCE = 0.05

obstacle_coordinates = {}
iteration_count_ = 0

# Stores the coordinates of the obstacl positions for robots that have actually sensed a robot
robot_obstacle_global_position_ = {}

# Final number of obstacles
final_obstacle_count_ = 0

# Declaration
temp_obstacle_count = {}

# Stores the number of obstacles believed by a particular robot
robot_obstacle_count_belief_ = {}
BYZANTINE_ROBOT_IDS = {.0 = 3, .1 = 5}

# ----- Function to Start the Buzz Script - Runs only once -----
function init() {
  log("Obstacle Couting in Presence of Lying Agents for Khepera IV using Buzz")
  initRobotObstacleCounts()
  initTempObstacleCount()
  printTable(robot_obstacle_count_belief_)
}

# ----- Function to run on each timestep -----
function step() {
  # log("Iteration Number: ", iteration_count_, ", Robot ID" , id, ", Robot Counter: ", iteration_count_ % 8)
  iteration_count_ = iteration_count_ + 1
  # Main Function that encapsulates everything running within  
  main()
  neighborListening()
  temp_obstacle_count = {}
}

# Main function for execution
function main() {
  obstacleAvoidance()
  # printTable(robot_obstacle_count_belief_)
  neighbors.broadcast("obstacle_count", robot_obstacle_count_belief_)
  updateShareRobotCountBelief()
}

# Robot Obstacle Counter Initialization & Byzantine Behavior Injection
function initRobotObstacleCounts() {
  var i = 0
  while (i < NUM_ROBOTS) {
    robot_obstacle_count_belief_[id] = 0
    var j = 0
    size_byzantines = size(BYZANTINE_ROBOT_IDS) 
    while (j < size_byzantines) {
      if (id == BYZANTINE_ROBOT_IDS[j]) {
        robot_obstacle_count_belief_[id] = 10
      }
      j = j + 1
    }
    i = i + 1
  }
}


function initTempObstacleCount() {
  var i = 0
  while (i < NUM_ROBOTS) {
    temp_obstacle_count[id] = 0
    i = i + 1
  }  
}

# Function for Obstacle Avoidance - Computes the vector sum of all the individual 
# proximity sensor to confirm if an obstacle exists and needs to be dodged or not
function obstacleAvoidance() {

  # Track the trajectory on the canvas
  debug.trajectory.enable(50, 255, 0, 0)

  vector_accumulator = {.x = 0, .y = 0}
  var obstacle_robot_pose = {}

  i = 0
  while (i<8) {
    var dist = proximity[i].value
    var orient = proximity[i].angle
    # Compute the actual distance of the obstacle based on the proximity sensor reading that exists between 0 and 1
    # From https://the.swarming.buzz/wiki/doku.php?id=buzz_kh4
    var rel_dist = (math.log((dist + 0.085) / 4.14)) / -33.0

    var obstacle_rel_position = math.vec2.newp(dist, orient)
    vector_accumulator = math.vec2.add(vector_accumulator, obstacle_rel_position)
    i = i+1
  }

  # Create a vec2 for the robot position
  obstacle_robot_pose = math.vec2.new(pose.position.x, pose.position.y)
  debug.print("X: ", obstacle_robot_pose.x, ", Y: ", obstacle_robot_pose.y, " | Num Obs Ctr: ", robot_obstacle_count_belief_[id])

  # Obstacle Avoidance Algorithm
  if (math.vec2.length(vector_accumulator) < DISTANCE_THRESHOLD) {
    set_leds(0, 255, 0)
    set_wheels(30.0,30.0)
  } else {
    set_leds(255, 0, 0)
    if (orient > 0) {
      set_wheels(30.0,0.0)
    } else if (orient < 0) {
      set_wheels(0.0,30.0)
    }

    # Check of the obstacle is almost a wall or NOT
    var is_wall = isObstacleWall(obstacle_robot_pose)

    # If the obstacle is NOT a WALL, then proceed towards checking the uniqueness of the obstacle
    if (is_wall == 0) {
      debug.print("Robot Hit Obstacle | ", " Num Obs Ctr: ", robot_obstacle_count_belief_[id])

      var counter = 0
      var vector_size = size(robot_obstacle_global_position_)

      var cumulative_sum = 0
      var is_approx_status = 0

      log("Rbt ID: ", id, " | Ctr: ", counter, " | Cum: " , cumulative_sum , " | Obs Vec Size:", vector_size)

      # Check for if obstacles are the same or NOT
      while (counter < vector_size) {
        # Check if one of the unique obstacles matches the current obstacle position
        is_approx_status = isVectorApprox(robot_obstacle_global_position_[counter], obstacle_robot_pose)

        if (is_approx_status == 1) {
          var temp_sum = math.vec2.add(robot_obstacle_global_position_[counter], obstacle_robot_pose)
          robot_obstacle_global_position_[counter] = math.vec2.scale(temp_sum, 0.5)
        } else if (is_approx_status == 0) {
          cumulative_sum = cumulative_sum + 1
        }
        counter = counter + 1
      } 
      if (cumulative_sum == vector_size) {
        log("Robot ID: ", id, " | Sum Equal ", obstacle_robot_pose, " | Vector Size: ", vector_size)
        robot_obstacle_global_position_[vector_size] = obstacle_robot_pose
         # = obstacle_robot_pose
      }

    } else if (is_wall == 1) {
      debug.print("Robot Hit Wall | ", "Num Obs Ctr: ", robot_obstacle_count_belief_[id])
    }

  }
}

function updateShareRobotCountBelief() {
  var temporary_sum = 0 
  foreach(temp_obstacle_count,
    function(key, value) {
      temporary_sum = temporary_sum + value
    })
  # Average of robot's own belief and average of the other robot's blief and then floored
  # final_obstacle_count_[id] = (final_obstacle_count_[id] + (temporary_sum/size(temp_obstacle_count)))/2 
  # final_obstacle_count_[id] = math.floor(final_obstacle_count_[id])
  robot_obstacle_count_belief_[id] = (robot_obstacle_count_belief_[id] + (temporary_sum/size(temp_obstacle_count)))/2 
  robot_obstacle_count_belief_[id] = math.floor(robot_obstacle_count_belief_[id])

}

# Make the robots listen to the other robots sharing the (key, value) pair with key = OBSTACLE_COUNT
function neighborListening() {
  temp_obstacle_count = {}
  neighbors.listen("obstacle_count",
   function(vid, value, rid) {
      log("Rbt: ", id, ", Got (", vid, ",", value, ") from robot #", rid)
      temp_obstacle_count[rid] = value
   })
}

# Function to check if two positions are close enought to be the same or not
# (Threshold here is 5 cm)
function isVectorApprox(vector1, vector2) {
  var temp_vec = math.vec2.sub(vector1, vector2)
  var obs_dist = math.vec2.length(temp_vec)
  # log("Robot ID: ", id, " | Distance between Obstacles: ", obs_dist)
  if (obs_dist < APPROX_OBS_DISTANCE) {
    return 1
  } else {
    return 0
  }
}


# Prints the contents of any provided table
function printTable(new_table) {
  foreach(new_table,
    function(keya, valuea) {
      log("Table Key: ", keya, ", Table Value : ", valuea)
    })
}

# Function to check if the obstacle is actually a WALL or not 
# The obstacle distribution is only until +3.5 m to -3.5 m on the X and Y axes
# So When the robot's position is 0.5m out from the arena limits(4m), then the obstacle is only WALL and thus not counted
function isObstacleWall(obstacle_position) {
  var is_obstacle_wall = 0
  if (obstacle_position.x > (WALL_DIAGONAL_COORDINATES.x1 - PADDING)) {
    is_obstacle_wall = 1
  } else if (obstacle_position.x < (WALL_DIAGONAL_COORDINATES.x2 + PADDING)) {
    is_obstacle_wall = 1
  } else if (obstacle_position.y > (WALL_DIAGONAL_COORDINATES.y1 - PADDING)) {
    is_obstacle_wall = 1
  } else if (obstacle_position.y < (WALL_DIAGONAL_COORDINATES.y2 + PADDING)) {
    is_obstacle_wall = 1
  }
  log("Robot ID: ", id, " | Is Obstacle Wall: ", is_obstacle_wall)
  return is_obstacle_wall
}

# Function to compute and save the locations of things that can NOT be an obstacle
# Such things include the walls and the other robots that are detected.


function reset() {}

function destroy() {}