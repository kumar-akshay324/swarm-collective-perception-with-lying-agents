include "/usr/local/share/buzz/include/vec2.bzz"
include "/usr/local/share/buzz/include/string.bzz"
include "/media/akshay/anything_Else/WorcesterPolytechnicInstitute/SemIV/DirectedResearch/collective-perception-with-lying-agents/buzz/helpers.bzz"


# Global constant for Obstacle Avoidance
NUM_ROBOTS = 8
OBS_DIST_THRESHOLD = 0.05
NUMBER_PROXIMITY_SENSORS = 8

# Global constant for isWallCheck()
PADDING = 0.5
WALL_DIAGONAL_COORDINATES = {.x1 = 4, .y1 = 4, .x2 = -4, .y2 = -4}

# Approx distance threshold
APPROX_OBS_DISTANCE = 0.05

obstacle_coordinates = {}
iteration_count_ = 0

# Stores the coordinates of the obstacle positions for all robots
robot_obstacle_global_position_ = {}

# Final number of obstacles
final_obstacle_count_ = 0

# Declaration
temp_obstacle_count = {}

# Stores the number of obstacles believed by a particular robot
robot_obstacle_count_belief_ = {}
BYZANTINE_ROBOT_IDS = {.0 = 3, .1 = 5}

# Current robot position
robot_current_position_ = {}
APPROX_RBT_DISTANCE = 0.10

# ----- Function to Start the Buzz Script - Runs only once -----
function init() {
  log("Obstacle Couting in Presence of Lying Agents for Khepera IV using Buzz")
  initRobotObstacleBeliefs()
  initRobotCurrentPosition()
  # printTable(robot_obstacle_count_belief_)
}

# ----- Function to run on each timestep -----
function step() {

  iteration_count_ = iteration_count_ + 1
  # log("Iteration Number: ", iteration_count_, ", Robot ID" , id, ", Robot Counter: ", iteration_count_ % 8)

  # Store the robot's current position
  storeRobotCurrentPosition(iteration_count_)

  # Main Function that encapsulates everything running within  
  main()
  log("Size: ", size(robot_current_position_))
  log("Iter: ", iter)
  # neighborListening()
  # temp_obstacle_count = {}
}

function storeRobotCurrentPosition(iteration_count_) {
  # robot_current_position_[iteration_count_ % NUM_ROBOTS] = {}
  var temp_table = {.x = pose.position.x, .y = pose.position.y}
  # printTable(temp_table)
  var num = id
  robot_current_position_[iteration_count_ % NUM_ROBOTS] = temp_table
  # robot_current_position_[num] = 
  # Print the robot's current
  printRobotCurrentPosition()
}

function initRobotCurrentPosition() {
  var i = 0
  while (i < NUM_ROBOTS) {
    robot_current_position_[i] = {.x = 0, .y = 0}
    i = i + 1
  }
}


# Main function for execution
function main() {
  obstacleAvoidance()
  # printTable(robot_obstacle_count_belief_)
  # neighbors.broadcast("obstacle_count", robot_obstacle_count_belief_)
  # updateShareRobotCountBelief()
}

# Robot Obstacle Counter Initialization & Byzantine Behavior Injection
function initRobotObstacleBeliefs() {
  var i = 0
  while (i < NUM_ROBOTS) {

    robot_obstacle_count_belief_[id] = {}

    # Byzantine Behavior Infusion
    # var j = 0
    # size_byzantines = size(BYZANTINE_ROBOT_IDS)
    # while (j < size_byzantines) {
    #   if (id == BYZANTINE_ROBOT_IDS[j]) {
    #     robot_obstacle_count_belief_[id] = {.0 = {.x = 0, .y = 0}}
    #   }
    #   j = j + 1
    # }

    i = i + 1
  }
}

# Function for Obstacle Avoidance - Computes the vector sum of all the individual 
# proximity sensor to confirm if an obstacle exists and needs to be dodged or not
function obstacleAvoidance() {

  # Track the trajectory on the canvas
  debug.trajectory.enable(50, 255, 0, 0)

  vector_accumulator = {.x = 0, .y = 0}
  var obstacle_robot_pose = {}

  i = 0
  while (i<NUM_ROBOTS) {
    var dist = proximity[i].value
    var orient = proximity[i].angle
    # Compute the actual distance of the obstacle based on the proximity sensor reading that exists between 0 and 1
    # From https://the.swarming.buzz/wiki/doku.php?id=buzz_kh4
    var rel_dist = (math.log((dist + 0.085) / 4.14)) / -33.0

    var obstacle_rel_position = math.vec2.newp(dist, orient)
    vector_accumulator = math.vec2.add(vector_accumulator, obstacle_rel_position)
    i = i+1
  }

  # Create a vec2 for the robot position
  obstacle_robot_pose = math.vec2.new(pose.position.x, pose.position.y)
  debug.print("X: ", obstacle_robot_pose.x, ", Y: ", obstacle_robot_pose.y)

  # Obstacle Avoidance Algorithm
  if (math.vec2.length(vector_accumulator) < OBS_DIST_THRESHOLD) {
    set_leds(0, 255, 0)
    set_wheels(30.0,30.0)
  } else {
    set_leds(255, 0, 0)
    if (orient > 0) {
      set_wheels(30.0,0.0)
    } else if (orient < 0) {
      set_wheels(0.0,30.0)
    }

    # Check of the obstacle is almost a wall or NOT
    var is_wall = isObstacleWall(obstacle_robot_pose)
    var is_another_robot = isAnotherRobot(obstacle_robot_pose)

    # If the obstacle is NOT a WALL, then proceed towards checking the uniqueness of the obstacle
    if ((is_wall == 0) and (is_another_robot == 0)) {
      debug.print("Robot Hit Obstacle")
      log.print("Robot Hit Obstacle")

      var counter = 0
      var vector_size = size(robot_obstacle_global_position_)

      var cumulative_sum = 0
      var is_approx_status = 0

      # log("Rbt ID: ", id, " | Ctr: ", counter, " | Cum: " , cumulative_sum , " | Obs Vec Size:", vector_size)

      # Check for if obstacles are the same or NOT
      while (counter < vector_size) {
        # Check if one of the unique obstacles matches the current obstacle position
        is_approx_status = isVectorApprox(robot_obstacle_global_position_[counter], obstacle_robot_pose, APPROX_OBS_DISTANCE)

        if (is_approx_status == 1) {
          var temp_sum = math.vec2.add(robot_obstacle_global_position_[counter], obstacle_robot_pose)
          robot_obstacle_global_position_[counter] = math.vec2.scale(temp_sum, 0.5)
        } else if (is_approx_status == 0) {
          cumulative_sum = cumulative_sum + 1
        }
        counter = counter + 1
      } 
      if (cumulative_sum == vector_size) {
        # log("Robot ID: ", id, " | Sum Equal ", obstacle_robot_pose, " | Vector Size: ", vector_size)
        robot_obstacle_global_position_[vector_size] = obstacle_robot_pose
         # = obstacle_robot_pose
      }

    } else if (is_wall == 1) {
      debug.print("Robot Hit Wall")
    } else if (is_another_robot == 1) {
      log("ID:: ", id, " Robot Hit Obstacle")
      debug.print("Robot Hit another robot")    
    }

  }
}

function updateShareRobotCountBelief() {
  var temporary_sum = 0 
  foreach(temp_obstacle_count,
    function(key, value) {
      temporary_sum = temporary_sum + value
    })
  # Average of robot's own belief and average of the other robot's blief and then floored
  # final_obstacle_count_[id] = (final_obstacle_count_[id] + (temporary_sum/size(temp_obstacle_count)))/2 
  # final_obstacle_count_[id] = math.floor(final_obstacle_count_[id])
  robot_obstacle_count_belief_[id] = (robot_obstacle_count_belief_[id] + (temporary_sum/size(temp_obstacle_count)))/2 
  robot_obstacle_count_belief_[id] = math.floor(robot_obstacle_count_belief_[id])

}

# Make the robots listen to the other robots sharing the (key, value) pair with key = OBSTACLE_COUNT
# function neighborListening() {
#   temp_obstacle_count = {}
#   neighbors.listen("obstacle_count",
#    function(vid, value, rid) {
#       log("Rbt: ", id, ", Got (", vid, ",", value, ") from robot #", rid)
#       temp_obstacle_count[rid] = value
#    })
# }





# Function to check if the obstacle is actually a WALL or not 
# The obstacle distribution is only until +3.5 m to -3.5 m on the X and Y axes
# So When the robot's position is 0.5m out from the arena limits(4m), then the obstacle is only WALL and thus not counted
function isObstacleWall(obstacle_position) {
  var is_obstacle_wall = 0
  if (obstacle_position.x > (WALL_DIAGONAL_COORDINATES.x1 - PADDING)) {
    is_obstacle_wall = 1
  } else if (obstacle_position.x < (WALL_DIAGONAL_COORDINATES.x2 + PADDING)) {
    is_obstacle_wall = 1
  } else if (obstacle_position.y > (WALL_DIAGONAL_COORDINATES.y1 - PADDING)) {
    is_obstacle_wall = 1
  } else if (obstacle_position.y < (WALL_DIAGONAL_COORDINATES.y2 + PADDING)) {
    is_obstacle_wall = 1
  }
  # log("Robot ID: ", id, " | Is Obstacle Wall: ", is_obstacle_wall)
  return is_obstacle_wall
}

# Function to compute if the current obstacle is another robot or not
function isAnotherRobot(pose_contender) {
  foreach(robot_current_position_,
    function(key, value) {
      var distance = math.sqrt((pose_contender.x - value.x)^2 + (pose_contender.y - value.y)^2)
      if ((distance < APPROX_RBT_DISTANCE) and (distance != 0)) {
        log("-- ID: ", id, ", D: ", distance)
        debug.print("Robot Hit Another Robot")
        return 1
      } else {
        return 0
      }
    }
  )
}


function printRobotCurrentPosition() {
  var j = 0
  while (j < size(robot_current_position_)) {
    log("--ID: ", j, ", X: ", robot_current_position_[j].x, ", Y: " ,robot_current_position_[j].y)
    j = j + 1
  }
}


function reset() {}

function destroy() {}