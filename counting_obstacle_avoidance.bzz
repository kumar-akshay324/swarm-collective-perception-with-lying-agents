include "include/string.bzz"
include "include/vec2.bzz"

# Global variables

DISTANCE_THRESHOLD = 0.001

OBSTACLE_COORDINATES = {}
WALL_DIAGONAL_COORDINATES = {.x1 = 4, .y1 = 4, .x2 = -4, .y2 = -4}

OBSTACLE_COUNT_BELIEF = 0
NUMBER_PROXIMITY_SENSORS = 8

# ----- Helper Functions for Obstacle Avoidance-----

# Function to compute the position from the distance and angle readings
function computePositionFromReadings(length, angle) {
   var local_position_vector 
   # var length = 4.14*(math.exp(-33.0*expressed_length))- 0.085
   # print ("(", "Length: ", length, ")")
   local_position_vector = { .x = length * math.cos(angle),.y = length * math.sin(angle) }
   return local_position_vector
}

# Function to compute the new position depending upon two coordinates
function computePosition(pos1, pos2) {
  var new_position_x = pos1.x + pos2.x
  var new_position_y = pos1.y + pos2.y
  pos1.x = new_position_x
  pos1.y = new_position_y 
  return pos1
}

# Function to compute the orientation in global FOR give the position (x, y) coordinates
function computeOrientation(pos) {
  var orientation = math.atan(pos.y, pos.x)
  return orientation
}

# Helper Functions for Obstacle Counting
# function 

# ----- Function to Start the Buzz Script -----
function init() {
  log("Obstacle avoidance for Khepera IV using Buzz")
  # log.flush()
}

# ----- Function to run on each timestep -----

iteration = 0

function step() {
  # log("Iteration Number: ", iteration)
  iteration = iteration + 1
  var final_rel_obstacle_position = obstacleAvoidance()
  computeOwnPosition(final_rel_obstacle_position)
  # main()

}

# Obstacle Avoidance Algorithm
function obstacleAvoidance() {

  var i = 0
  var final_rel_obstacle_pos = {.x = 0 , .y = 0 }
  temp_pos = {}
  while (i < NUMBER_PROXIMITY_SENSORS) 
  {

  distance = proximity[i].value             # Sensor reading
  orientation = proximity[i].angle          # Sensor reading

  # Position of the obstacle with respect to the robot
  temp_pos.i = computePositionFromReadings(distance, orientation)

  final_rel_obstacle_pos = computePosition(temp_pos.i, final_rel_obstacle_pos)

  i = i+1
  # log("Final Position = ", final_rel_obstacle_pos.x, " ", final_rel_obstacle_pos.y )
  }

  # Iteratively updating the distance and orientation of the obstacle
  orient = computeOrientation(final_rel_obstacle_pos)

  dist = math.sqrt(final_rel_obstacle_pos.x*final_rel_obstacle_pos.x + final_rel_obstacle_pos.y*final_rel_obstacle_pos.y)
  dist_final = dist/3
  # log("Orientation: ",orient)
  # log("Distance: ", dist_final)

  # ---- Avoidance Conditions
  if (dist_final < DISTANCE_THRESHOLD){
   set_wheels(30.0,30.0)
  } 
  if ((orient == 0.0) and (dist_final > DISTANCE_THRESHOLD)){
   set_wheels(30.0, 0.0)
  }
  if ((orient < 1.57) and (orient > 0.0)){
   set_wheels(30.0,0.0)
  }
  if ((orient > -1.57) and (orient < 0.0)){
    set_wheels(0.0,30.0)
  }
  return final_rel_obstacle_pos
}

function computeObstacleGlobalPosition(final_rel_obstacle_position) {

  var robot_yaw_angle = robot_pose.orientation.yaw

  # if final_rel_obstacle_position 

  var obstacle_global_pos = {.x = 0, .y = 0}
  obstacle_global_pos.x = robot_pose.position.x + final_rel_obstacle_position.x * math.cos(robot_yaw_angle) + final_rel_obstacle_position.y * math.sin(robot_yaw_angle)
  obstacle_global_pos.y = robot_pose.position.y - final_rel_obstacle_position.x * math.sin(robot_yaw_angle) + final_rel_obstacle_position.y * math.cos(robot_yaw_angle)

  # debug.print()
  return obstacle_global_pos
  
}

# Main function for execution
function main() {
  tab = {.k = {.x = 0.4, .y = 0.5}, .l = {.x = 11.0, .y = 55}}
  log(tab.k.x)
  log(tab.k.y)
  log(tab.l.x)
  log(tab.l.y)

}

# Function to compute own position
function computeOwnPosition(final_rel_obstacle_position) {
  # Iteratively compute own position in space
  robot_pose = pose
  var robot_position = pose.position
  var robot_orient = pose.orientation
  var obs_global_pos = computeObstacleGlobalPosition(final_rel_obstacle_position)

  debug.print(" X: ", robot_position.x, " Y: ", robot_position.y, " Z: ", robot_position.z, " H: ", robot_orient.yaw, "Obs X:", obs_global_pos.x, "Obs Y:", obs_global_pos.y)

}


# Function to store positions of unique obstacles
function StoreUniqueObstacles(other_obstacle_position) {
  
  var counter = 0

  while ( counter < size(OBSTACLE_COORDINATES)) {
    if ((other_obstacle_position.x == OBSTACLE_COORDINATES[counter].x) and (other_obstacle_position.y == OBSTACLE_COORDINATES[counter].y)) {
      debug.print("Num Obstacles: ", 1)
    }
 }
  
}

function shareBelief() {
  
}


# Function to setup the robots to join a swarm
function SetupSwarm() {

  robot_swarm = swarm.create()
  var i = 0
  while (i < 10) {
    robot_swarm.select(i)
  }
  return robot_swarm                              # Returning a robot swarm of 15 robots
}


# # Function to setup the communication protocol for the robot
# function SetupSwarmCommunication() {

# }


# # Function to compute and save the locations of things that can NOT be an obstacle
# # Such things include the walls and the other robots that are detected.


function reset() {}

function destroy() {}