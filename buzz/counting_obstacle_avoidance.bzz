include "/usr/local/share/buzz/include/vec2.bzz"
include "/usr/local/share/buzz/include/string.bzz"

# Global variables
NUM_ROBOTS = 8
DISTANCE_THRESHOLD = 0.05
NUMBER_PROXIMITY_SENSORS = 8

PADDING = 0.5
WALL_DIAGONAL_COORDINATES = {.x1 = 4, .y1 = 4, .x2 = -4, .y2 = -4}
APPROX_OBS_DISTANCE = 0.05

obstacle_coordinates = {}
iteration_count_ = 0

# Stores the coordinates of the obstacl positions for robots that have actually sensed a robot
robot_obstacle_global_position_ = {}

# Stores the number of obstacles believed by a particular robot
robot_obstacle_count_belief_ = {}


# Helper Functions for Obstacle Counting
# function 

# ----- Function to Start the Buzz Script -----
function init() {
  log("Obstacle Couting in Presence of Lying Agents for Khepera IV using Buzz")
}

# ----- Function to run on each timestep -----

function step() {
  # log("Iteration Number: ", iteration_count_, ", Robot ID" , id, ", Robot Counter: ", iteration_count_ % 8)
  iteration_count_ = iteration_count_ + 1
  # Main Function that encapsulates everything running within  
  main()
}

# Main function for execution
function main() {
  obstacleAvoidance()

  neighbors.broadcast("obstacle_count", obstacle_count_)
}


# Function for Obstacle Avoidance - Computes the vector sum of all the individual 
# proximity sensor to confirm if an obstacle exists and needs to be dodged or not

function obstacleAvoidance() {

  # Track the trajectory on the canvas
  debug.trajectory.enable(50, 255, 0, 0)

  vector_accumulator = {.x = 0, .y = 0}
  var obstacle_robot_pose = {}

  i = 0
  while (i<8) {
    var dist = proximity[i].value
    var orient = proximity[i].angle
    # Compute the actual distance of the obstacle based on the proximity sensor reading that exists between 0 and 1
    # From https://the.swarming.buzz/wiki/doku.php?id=buzz_kh4
    var rel_dist = (math.log((dist + 0.085) / 4.14)) / -33.0

    var obstacle_rel_position = math.vec2.newp(dist, orient)
    vector_accumulator = math.vec2.add(vector_accumulator, obstacle_rel_position)
    i = i+1
  }

  # Create a vec2 for the robot position
  obstacle_robot_pose = math.vec2.new(pose.position.x, pose.position.y)
  debug.print("Robot X: ", obstacle_robot_pose.x, ", Robot Y: ", obstacle_robot_pose.y)

  # Obstacle Avoidance Algorithm
  if (math.vec2.length(vector_accumulator) < DISTANCE_THRESHOLD) {
    set_leds(0, 255, 0)
    set_wheels(30.0,30.0)
  } else {

    # Check of the obstacle is almost a wall or NOT
    var is_wall = isObstacleWall(obstacle_robot_pose)

    # If the obstacle is NOT a WALL, then proceed towards checking the uniqueness of the obstacle
    if (is_wall == 0) {
      debug.print("Robot Hit Obstacle: ")

      var counter = 0
      var vector_size = size(robot_obstacle_global_position_)

      var cumulative_sum = 0
      var is_approx_status = 0

      log("Robot ID: ", id, " | Counter: ", counter, " | Cumulative: " , cumulative_sum , " | Obs Vec Size:", vector_size)


      # Check for if obstacles are the same or NOT
      while (counter < vector_size) {
        log("In Here")
      #   # Check if one of the unique obstacles matches the current obstacle position
      #   is_approx_status = isVectorApprox(robot_obstacle_global_position_[counter], obstacle_robot_pose)

      #   if (is_approx_status == 1) {
      #     var temp_sum = math.vec2.add(robot_obstacle_global_position_[counter], obstacle_robot_pose)
      #     robot_obstacle_global_position_[counter] = math.vec2.scale(temp_sum, 0.5)
      #   } else if (is_approx_status == 0) {
      #     cumulative_sum = cumulative_sum + 1
      #   }
        counter = counter + 1
      } 
      if (cumulative_sum == vector_size) {
        log("Robot ID: ", id, " | Sum Equal ", obstacle_robot_pose, " | Vector Size: ", vector_size)
        robot_obstacle_global_position_[vector_size] = obstacle_robot_pose
         # = obstacle_robot_pose
      }

    } else if (is_wall == 1) {
      debug.print("Robot Hit Wall")
    }
    set_leds(255, 0, 0)
    if (orient > 0) {
      set_wheels(30.0,0.0)
    } else if (orient < 0) {
      set_wheels(0.0,30.0)
    }
  }  
}




function isVectorApprox(vector1, vector2) {
  var temp_vec = math.vec2.sub(vector1, vector2)
  var obs_dist = math.vec2.length(temp_vec)
  log("Robot ID: ", id, " | Distance between Obstacles: ", obs_dist)
  if (obs_dist < APPROX_OBS_DISTANCE) {
    return 1
  } else {
    return 0
  }
}

function printTable(new_table) {
  foreach(new_table,
    function(keya, valuea) {
      log("Table Key: ", keya, ", Value X: ", valuea)
    })
}

function isObstacleWall(obstacle_position) {
  var is_obstacle_wall = 0
  if (obstacle_position.x > (WALL_DIAGONAL_COORDINATES.x1 - PADDING)) {
    is_obstacle_wall = 1
  } else if (obstacle_position.x < (WALL_DIAGONAL_COORDINATES.x2 + PADDING)) {
    is_obstacle_wall = 1
  } else if (obstacle_position.y > (WALL_DIAGONAL_COORDINATES.y1 - PADDING)) {
    is_obstacle_wall = 1
  } else if (obstacle_position.y < (WALL_DIAGONAL_COORDINATES.y2 + PADDING)) {
    is_obstacle_wall = 1
  }
  log("Robot ID: ", id, " | Is Obstacle Wall: ", is_obstacle_wall)
  return is_obstacle_wall
}

# # Function to compute and save the locations of things that can NOT be an obstacle
# # Such things include the walls and the other robots that are detected.


function reset() {}

function destroy() {}